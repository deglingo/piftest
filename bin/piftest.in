#!@PYTHON@
# -*- python -*-

import sys, os, getopt, configparser, subprocess, re, pprint, tempfile, shlex, glob

# trace:
def trace (msg) :
    sys.stderr.write('piftest: %s\n' % msg)

# Config:
class Config :

    # __init__:
    def __init__ (self) :
        self.progpath = os.path.realpath(sys.argv[0])
        self.cfgfile = 'piftest.conf'

    # read_file:
    def read_file (self) :
        parser = configparser.ConfigParser()
        parser.read_file(open(self.cfgfile, 'rt'))
        self.suite = parser['DEFAULT']['suite']
        self.srcdir = parser['DEFAULT']['srcdir']
        self.makefile = self.suite + '.mk'
        self.modules = shlex.split(parser['DEFAULT']['modules'])
        self.cflags = parser['DEFAULT']['cflags']
        self.ldflags = parser['DEFAULT']['ldflags']

# Writer:
class Writer :

    # __init__:
    def __init__ (self) :
        self.root = WSection()

    # get_section:
    def get_section (self, path) :
        s = self.root
        if path != '' :
            for comp in path.split('.') :
                s = s.children[comp]
        return s

    # section:
    def section (self, path) :
        dot = path.rfind('.')
        if dot < 0 :
            parent = self.root
            name = path
        else :
            parent = self.get_section(path[:dot])
            name = path[dot+1:]
        parent.add_child(name)

    # write:
    def write (self, section, *text) :
        s = self.get_section(section)
        s.write(*text)
        
    # write_rule:
    def write_rule (self, section, targets, prereqs=None, recipe=None) :
        s = self.get_section(section)
        s.write_rule(targets, prereqs, recipe)

    # dump:
    def dump (self, f) :
        self.root.dump(f)

# WSection:
class WSection :

    # __init__:
    def __init__ (self) :
        self.nodes = []
        self.children = {}

    # add_child:
    def add_child (self, name) :
        assert name not in self.children, name
        child = WSection()
        self.nodes.append(child)
        self.children[name] = child
        
    # dump:
    def dump (self, f) :
        for n in self.nodes :
            n.dump(f)

    # write:
    def write (self, *text) :
        self.nodes.extend(WText(t) for t in text)

    # write_rule:
    def write_rule (self, targets, prereqs=None, recipe=None) :
        self.nodes.append(WRule(targets, prereqs, recipe))

# WText:
class WText :

    # __init__:
    def __init__ (self, text) :
        self.text = text

    # dump:
    def dump (self, f) :
        f.write(self.text)

# WRule:
class WRule :

    # __init__
    def __init__ (self, targets, prereqs=None, recipe=None) :
        self.targets = self._fixlist(targets)
        self.prereqs = self._fixlist(prereqs)
        self.recipe = self._fixlist(recipe)

    def _fixlist (self, arg) :
        if arg is None : return ()
        elif isinstance(arg, str) : return (arg,)
        else : return tuple(arg)

    # dump:
    def dump (self, f) :
        f.write(' '.join(self.targets))
        f.write(': ')
        f.write(' '.join(self.prereqs))
        f.write('\n')
        for c in self.recipe :
            f.write('\t%s\n' % c)

# Token:
class Token :

    def __init__ (self, tp, val='') :
        self.tp = tp
        self.val = val

    def __repr__ (self) :
        return '<%s "%s">' % (self.tp, self.val.replace('\n', '\\n'))

# Parser:
class Parser :

    TOKEN_SPECS = (
        ('NL',  r'\n'),
        ('SPC', r'[ \t]+'),
        ('IDENT', r'[a-zA-Z_][a-zA-Z0-9_]*'),
        ('INT', r'[0-9]+'),
        ('SEMICOLON', r';'),
        ('OPEN_BRACE', r'\{'),
        ('CLOSE_BRACE', r'\}'),
        ('OPEN_PAR', r'\('),
        ('CLOSE_PAR', r'\)'),
    )

    RE_LEX = re.compile('|'.join('(?P<%s>%s)' % (n, r) for n, r in TOKEN_SPECS))

    RE_LOCATION = re.compile(r'#\s+(?P<LNO>\d+)\s+"(?P<FNAME>[^"]*)".*$')

    # __init__:
    def __init__ (self, modname) :
        self.modname = modname
        
    # parse:
    def parse (self, fin) :
        self.init(fin)
        ast = self.parse_input()
        return ast

    # init:
    def init (self, fin) :
        self.fin = fin
        self.tokbuf = []
        self.pos = 0
        self.buffer = ''
        
    # parse_input:
    def parse_input (self) :
        body = []
        while True :
            tok = self.look()
            if tok.tp == 'END' :
                break
            elif tok.tp == 'IDENT' :
                if tok.val == 'test' :
                    body.append(self.parse_test())
                else :
                    assert 0, tok
            else :
                assert 0, tok
        return ('unit', (), self.modname, None, None, None, tuple(body))

    # parse_test:
    def parse_test (self) :
        self.lex('IDENT', 'test')
        name = '' # [fixme]
        self.lex('OPEN_BRACE')
        code = []
        depth = 1
        while True :
            tok = self.lex(raw=True)
            if tok.tp == 'OPEN_BRACE' :
                depth += 1
            elif tok.tp == 'CLOSE_BRACE' :
                depth -= 1
                if depth == 0 :
                    break
            code.append(tok.val)
        return ('test', (), name, ''.join(code))

    # lex:
    def lex (self, tp=None, val=None, raw=False) :
        while True :
            if self.tokbuf :
                tok = self.tokbuf.pop()
            else :
                tok = self.__lex()
            if raw or tok.tp not in ('NL', 'SPC') :
                break
        assert tp is None or tp == tok.tp, (tp, tok)
        assert val is None or val == tok.val, (val, tok)
        return tok

    # unlex:
    def unlex (self, tok) :
        self.tokbuf.append(tok)

    # look:
    def look (self, raw=False) :
        tok = self.lex(raw=raw)
        self.unlex(tok)
        return tok

    # __lex:
    def __lex (self) :
        # feed the buffer
        while self.pos >= len(self.buffer) :
            self.pos = 0
            self.buffer = self.fin.readline()
            if self.buffer == '' :
                return Token('END')
            m = Parser.RE_LOCATION.match(self.buffer)
            if m is not None :
                lno = int(m.group('LNO'))
                fname = m.group('FNAME')
                # trace("[TODO] location: %d, '%s'" % (lno, fname))
                self.buffer = ''
        # get one token
        m = Parser.RE_LEX.match(self.buffer, self.pos)
        assert m is not None, self.buffer[self.pos:]
        assert m.start() == self.pos
        tp = m.lastgroup
        val = self.buffer[m.start():m.end()]
        self.pos = m.end()
        return Token(tp, val)

# ASTContext:
class ASTContext :

    parent = property(lambda s: s.__parent)
    
    def __init__ (self, parent) :
        self.__parent = parent
        self.__attrs = {}
        
    def __setattr__ (s, n, v) :
        if n[0] == '_' :
            object.__setattr__(s, n, v)
        else :
            s.__attrs[n] = v

    def __getattr__ (s, n) :
        if n[0] == '_' :
            return object.__getattr__(s, n)
        else :
            try: return s.__attrs[n]
            except KeyError: return getattr(s.__parent, n)

# ASTVisitor:
class ASTVisitor :

    # process:
    def process (self, node) :
        assert node[0] == 'unit'
        self.modname = node[2]
        self.context = ASTContext(None)
        self.context.unit_path = ''
        self.writer = Writer()
        self.writer.section('top')
        self.writer.section('includes')
        self.writer.section('fndecls')
        self.writer.section('modinit')
        self.writer.section('modinit.head')
        self.writer.section('modinit.body')
        self.writer.section('modinit.foot')
        self.writer.section('fndefs')
        self.writer.write('top', '/* AUTO-GENERATED FILE - DO NOT HAND EDIT! */\n')
        self.writer.write('includes',
                          '#include <piftest.h>\n',
                          '#include <piftools.h>\n')
        # init_func
        init_func = get_module_init_func(self.modname)
        self.writer.write('modinit.head',
                          'void %s ( PifSuite *suite )\n' % init_func,
                          '{\n')
        self.writer.write('modinit.foot',
                          '}\n')
        # go
        self.visit(node)

    # visit:
    def visit (self, node) :
        self.context = ASTContext(self.context)
        hdlr = getattr(self, 'visit_' + node[0])
        hdlr(node)
        self.context = self.context.parent

    # visit_unit:
    def visit_unit (self, node) :
        assert len(node) == 7, node
        tp, loc, name, data, setup, teardown, body = node
        # get unit path
        path = self.context.unit_path
        if path == '' : path = name
        else : path = path + '.' + name
        self.context.unit_path = path
        self.writer.write('modinit.body',
                          'pif_suite_register_unit(suite, "%s");\n' % path)
        for child in body :
            self.visit(child)

    # visit_test:
    def visit_test (self, node) :
        assert len(node) == 4
        tp, loc, name, code = node
        # get unit path
        path = self.context.unit_path
        if path == '' : path = name
        else : path = path + '.' + name
        self.context.unit_path = path
        test_func = get_test_func(path)
        self.writer.write('modinit.body',
                          'pif_suite_register_test(suite, "%s", %s);\n' %
                          (path, test_func))
        self.writer.write('fndecls',
                          'static void %s ( void );\n' % test_func)
        self.writer.write('fndefs',
                          'static void %s ( void )\n' % test_func,
                          '{\n')
        self.writer.write('fndefs', code)
        self.writer.write('fndefs',
                          '}\n')
        

# get_module_init_func:
def get_module_init_func (modname) :
    return '__%s__module_init' % modname

# get_test_func:
def get_test_func (path) :
    return '__%s__test_func' % path.replace('.', '_')

# newerthan:
#
# True if file2 does not exist or is older than file1. file1 can be a
# single filename or a list, in which case the function returns True
# if file2 is older than at least one of the files in it.
#
def newerthan (file1, file2) :
    if isinstance(file1, str) :
        file1 = (file1,)
    if not os.path.exists(file2) :
        return True
    stamp2 = os.path.getmtime(file2)
    for f in file1 :
        if os.path.getmtime(f) > stamp2 :
            return True
    return False
    
# main:
def main () :
    # create the config
    cfg = Config()
    # parse the command line
    shortopts = 'GMCBDE'
    cmd = ''
    src = ''
    dest = ''
    opts, args = getopt.gnu_getopt(sys.argv[1:], shortopts)
    for o, a in opts :
        if o in ('-M',) :
            assert not cmd
            cmd = 'gen-makefile'
        elif o in ('-G',) :
            assert not cmd
            cmd = 'gen-sources'
        elif o in ('-C',) :
            assert not cmd
            cmd = 'gen-source'
            assert len(args) == 2, args
            src, dest = args
        elif o in ('-B',) :
            assert not cmd
            cmd = 'gen-main'
            assert len(args) == 1, args
            dest, = args
        elif o in ('-D',) :
            assert not cmd
            cmd = 'gen-module-depends'
            assert len(args) == 1, args
            dest, = args
        elif o in ('-E',) :
            assert not cmd
            cmd = 'gen-main-depends'
            assert len(args) == 1, args
            dest, = args
        else :
            assert 0, (o, a)
    # read the config file
    cfg.read_file()
    # process
    if cmd == 'gen-makefile' :
        proc_gen_makefile(cfg)
    elif cmd == 'gen-sources' :
        proc_gen_sources(cfg)
    elif cmd == 'gen-source' :
        proc_gen_source(cfg, src, dest)
    elif cmd == 'gen-main' :
        proc_gen_main(cfg, dest)
    elif cmd == 'gen-module-depends' :
        proc_gen_module_depends(cfg, dest)
    elif cmd == 'gen-main-depends' :
        proc_gen_main_depends(cfg, dest)
    else :
        assert 0, cmd

# proc_gen_makefile:
def proc_gen_makefile (cfg) :
    trace("generating makefile: '%s'" % cfg.makefile)
    w = Writer()
    s = w.get_section('')
    mod_objs = [m+'.o' for m in cfg.modules]
    # makefile dependencies
    s.write_rule(cfg.makefile, [cfg.progpath, cfg.cfgfile])
    # main prog
    # [fixme] add $(LDFLAGS) ?
    s.write_rule(cfg.suite, [cfg.suite+'.o'] + mod_objs,
                 'libtool --tag=CC --mode=link $(CC) -o $@ $^ %s' %
                 (cfg.ldflags,))
    # objects compilation recipe
    s.write_rule('%.o', None,
                 'libtool --tag=CC --mode=compile $(CC) -c -o $@ $< $(CFLAGS) %s' %
                 (cfg.cflags,))
    # main source file
    s.write_rule(cfg.suite+'.c', [cfg.progpath, cfg.cfgfile],
                 '%s -B $@' % cfg.progpath)
    # modules sources generation rules
    s.write_rule([m+'.c' for m in cfg.modules], None,
                 '%s -C $< $@' % cfg.progpath)
    for mod in cfg.modules :
        s.write_rule(mod+'.c', [mod+'.in', cfg.progpath, cfg.cfgfile])
    # dependencies
    s.write('-include %s.d\n' % cfg.suite)
    for mod in cfg.modules :
        s.write('-include %s.d\n' % mod)
    s.write_rule(cfg.suite+'.d', None,
                 '%s -E $@' % cfg.progpath)
    s.write_rule([m+'.d' for m in cfg.modules], None,
                 '%s -D $@' % cfg.progpath)
    # output
    # trace("**  OUTPUT  **")
    # w.dump(sys.stderr)
    # trace("**************")
    tmpfile = cfg.makefile + '.tmp'
    with open(tmpfile, 'wt') as f :
        w.dump(f)
    os.rename(tmpfile, cfg.makefile)

# proc_gen_source:
def proc_gen_source (cfg, src, dest) :
    modname = os.path.splitext(os.path.basename(dest))[0]
    trace("generating module '%s' ('%s' -> '%s')" %
          (modname, src, dest))
    cpp_cmd = ['cpp', src]
    cpp_proc = subprocess.Popen(cpp_cmd,
                                stdout=subprocess.PIPE,
                                universal_newlines=True)
    parser = Parser(modname)
    ast = parser.parse(cpp_proc.stdout)
    r = cpp_proc.wait()
    assert r == 0, r
    trace("AST:\n%s" % pprint.pformat(ast))
    visitor = ASTVisitor()
    visitor.process(ast)
    # output
    tmpfile = dest + '.tmp'
    with open(tmpfile, 'wt') as f :
        visitor.writer.dump(f)
    os.rename(tmpfile, dest)

# proc_gen_main:
def proc_gen_main (cfg, dest) :
    trace("generating main source: '%s'" % dest)
    w = Writer()
    w.section('includes')
    w.section('fndecls')
    w.section('main')
    w.section('main.head')
    w.section('main.decls')
    w.section('main.init')
    w.section('main.body')
    w.section('main.foot')
    w.write('includes',
            '#include <piftest.h>\n')
    w.write('main.head',
            'int main ()\n',
            '{\n')
    w.write('main.foot',
            '}\n')
    w.write('main.decls',
            'PifSuite *suite;\n')
    w.write('main.init',
            'suite = pif_suite_new("%s");\n' % cfg.suite)
    for mod in cfg.modules :
        init_func = get_module_init_func(mod)
        w.write('fndecls', 'void %s ( PifSuite *suite );\n' % init_func)
        w.write('main.init', '%s(suite);\n' % init_func)
    w.write('main.body',
            'pif_suite_run(suite, ".");\n',
            'return 0;\n')
    # output
    tmpfile = dest + '.tmp'
    with open(tmpfile, 'wt') as f :
        w.dump(f)
    os.rename(tmpfile, dest)

# proc_gen_module_depends:
def proc_gen_module_depends (cfg, dest) :
    modname = os.path.splitext(os.path.basename(dest))[0]
    trace("generating module depends: '%s' (%s)" %
          (modname, dest))
    fd, tmpfile = tempfile.mkstemp()
    try:
        os.close(fd)
        with open(tmpfile, 'wt') as f :
            f.write('#include <piftest.h>\n')
            f.write('#include <piftools.h>\n')
        depends = cpp_depends(tmpfile, cfg.cflags)
    finally:
        os.unlink(tmpfile)
    w = Writer()
    # [fixme] add progpath and cfgfile ?
    w.write_rule('',
                 modname+'.o',
                 [modname+'.c'] + depends)
    w.write_rule('',
                 dest,
                 [modname+'.in'] + depends)
    tmpfile = dest + '.tmp'
    with open(tmpfile, 'wt') as f :
        w.dump(f)
    os.rename(tmpfile, dest)

# proc_gen_main_depends:
def proc_gen_main_depends (cfg, dest) :
    trace("generating main depends: '%s'" % dest)
    fd, tmpfile = tempfile.mkstemp()
    try:
        os.close(fd)
        with open(tmpfile, 'wt') as f :
            f.write('#include <piftest.h>\n')
        depends = cpp_depends(tmpfile, cfg.cflags)
    finally:
        os.unlink(tmpfile)
    w = Writer()
    # [fixme] add progpath and cfgfile ?
    w.write_rule('',
                 cfg.suite+'.o',
                 [cfg.suite+'.c'] + depends)
    w.write_rule('',
                 dest,
                 depends)
    tmpfile = dest + '.tmp'
    with open(tmpfile, 'wt') as f :
        w.dump(f)
    os.rename(tmpfile, dest)

# cpp_depends:
def cpp_depends (fname, cflags) :
    cpp_cmd = ['cpp', '-M', fname]
    cpp_cmd.extend(shlex.split(cflags))
    # trace("> %s" % ' '.join(cpp_cmd))
    cpp_proc = subprocess.Popen(cpp_cmd,
                                stdout=subprocess.PIPE,
                                universal_newlines=True)
    first = True
    depends = []
    for line in cpp_proc.stdout :
        line = line.rstrip('\n')
        line = line.rstrip('\\')
        if first :
            target, line = line.split(':')
            first = False
        depends.extend(line.split())
    r = cpp_proc.wait()
    assert r == 0, r
    assert depends and depends[0] == fname, depends
    depends.pop(0)
    return depends

# proc_gen_sources:
def proc_gen_sources (cfg) :
    trace("generating sources")
    # list the modules
    modules = []
    for pat in cfg.modules :
        for fn in glob.glob(os.path.join(cfg.srcdir, pat + '.in')) :
            mname = os.path.splitext(os.path.basename(fn))[0]
            cname = mname + '.c'
            modules.append((mname, fn, cname))
    trace("found %d modules: %s" %
          (len(modules), ', '.join(m[0] for m in modules)))
    # generate the main C file (<suite>.c)
    main_c = cfg.suite + '.c'
    if newerthan((cfg.cfgfile, cfg.progpath), main_c) :
        trace("  + %s" % main_c)
        _proc_gen_main(cfg, main_c, modules)
    else :
        trace("  - %s" % main_c)
    # generate the modules
    for mod_name, mod_in, mod_c in modules :
        if newerthan((cfg.cfgfile, cfg.progpath, mod_in), mod_c) :
            trace("  + %s (%s)" % (mod_c, mod_in))
            _proc_gen_source(cfg, mod_name, mod_in, mod_c)
        else :
            trace("  - %s (%s)" % (mod_c, mod_in))

# _proc_gen_main:
def _proc_gen_main (cfg, main_c, modules) :
    w = Writer()
    w.section('includes')
    w.section('fndecls')
    w.section('main')
    w.section('main.head')
    w.section('main.decls')
    w.section('main.init')
    w.section('main.modinit')
    w.section('main.body')
    w.section('main.foot')
    # includes
    w.write('includes',
            '#include <piftest.h>\n')
    # main
    w.write('main.head',
            'int main ()\n',
            '{\n')
    w.write('main.foot',
            '}\n')
    # suite init
    w.write('main.decls',
            'PifSuite *suite;\n')
    w.write('main.init',
            'suite = pif_suite_new("%s");\n' % cfg.suite)
    # run
    w.write('main.body',
            'pif_suite_run(suite, ".");\n',
            'return 0;') # [todo]
    # modules
    for mod_name, mod_in, mod_c in modules :
        init_func = get_module_init_func(mod_name)
        w.write('fndecls',
                'void %s ( PifSuite *suite );\n' % init_func)
        w.write('main.modinit',
                '%s(suite);\n' % init_func)
    # output
    tmpfile = main_c + '.tmp'
    with open(tmpfile, 'wt') as f :
        w.dump(f)
    os.rename(tmpfile, main_c)

# _proc_gen_source:
def _proc_gen_source (cfg, mod_name, mod_in, mod_c) :
    # start cpp
    cpp_cmd = ['cpp', mod_in]
    cpp_proc = subprocess.Popen(cpp_cmd,
                                stdout=subprocess.PIPE,
                                universal_newlines=True)
    # parse output
    parser = Parser(mod_name)
    ast = parser.parse(cpp_proc.stdout)
    # terminate cpp
    r = cpp_proc.wait()
    assert r == 0, r
    # ...
    trace("AST:\n%s" % pprint.pformat(ast))
    # process the tree
    visitor = ASTVisitor()
    visitor.process(ast)
    # output
    tmpfile = mod_c + '.tmp'
    with open(tmpfile, 'wt') as f :
        visitor.writer.dump(f)
    os.rename(tmpfile, mod_c)

# exec
if __name__ == '__main__' :
    main()
