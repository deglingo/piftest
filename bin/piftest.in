#!@PYTHON@
# -*- python -*-

import sys, os, getopt, configparser, subprocess, re, pprint, tempfile, shlex, glob, errno

# trace:
def trace (msg) :
    sys.stderr.write('piftest: %s\n' % msg)

# Config:
class Config :

    # __init__:
    def __init__ (self) :
        self.progpath = os.path.realpath(sys.argv[0])
        self.builddir = ''

    # read_file:
    def read_file (self, cfgfile) :
        defaults = {
            'cflags': '',
            'ldflags': '',
        }
        self.cfgfile = os.path.realpath(cfgfile)
        parser = configparser.ConfigParser(defaults=defaults)
        parser.read_file(open(self.cfgfile, 'rt'))
        self.suite = parser['DEFAULT']['suite']
        # self.srcdir = parser['DEFAULT']['srcdir']
        self.modules = parser['DEFAULT']['modules'].split()
        self.cflags = parser['DEFAULT']['cflags']
        self.ldflags = parser['DEFAULT']['ldflags']

# Writer:
class Writer :

    # __init__:
    def __init__ (self) :
        self.root = WSection()

    # get_section:
    def get_section (self, path) :
        s = self.root
        if path != '' :
            for comp in path.split('.') :
                s = s.children[comp]
        return s

    # section:
    def section (self, path) :
        dot = path.rfind('.')
        if dot < 0 :
            parent = self.root
            name = path
        else :
            parent = self.get_section(path[:dot])
            name = path[dot+1:]
        parent.add_child(name)

    # write:
    def write (self, section, *text) :
        s = self.get_section(section)
        s.write(*text)
        
    # write_rule:
    def write_rule (self, section, targets, prereqs=None, recipe=None) :
        s = self.get_section(section)
        s.write_rule(targets, prereqs, recipe)

    # dump:
    def dump (self, f) :
        self.root.dump(f)

# WSection:
class WSection :

    # __init__:
    def __init__ (self) :
        self.nodes = []
        self.children = {}

    # add_child:
    def add_child (self, name) :
        assert name not in self.children, name
        child = WSection()
        self.nodes.append(child)
        self.children[name] = child
        
    # dump:
    def dump (self, f) :
        for n in self.nodes :
            n.dump(f)

    # write:
    def write (self, *text) :
        self.nodes.extend(WText(t) for t in text)

    # write_rule:
    def write_rule (self, targets, prereqs=None, recipe=None) :
        self.nodes.append(WRule(targets, prereqs, recipe))

# WText:
class WText :

    # __init__:
    def __init__ (self, text) :
        self.text = text

    # dump:
    def dump (self, f) :
        f.write(self.text)

# WRule:
class WRule :

    # __init__
    def __init__ (self, targets, prereqs=None, recipe=None) :
        self.targets = self._fixlist(targets)
        self.prereqs = self._fixlist(prereqs)
        self.recipe = self._fixlist(recipe)

    def _fixlist (self, arg) :
        if arg is None : return ()
        elif isinstance(arg, str) : return (arg,)
        else : return tuple(arg)

    # dump:
    def dump (self, f) :
        f.write(' '.join(self.targets))
        f.write(': ')
        f.write(' '.join(self.prereqs))
        f.write('\n')
        for c in self.recipe :
            f.write('\t%s\n' % c)

# Token:
class Token :

    def __init__ (self, tp, val='') :
        self.tp = tp
        self.val = val

    def __repr__ (self) :
        return '<%s "%s">' % (self.tp, self.val.replace('\n', '\\n'))

# Parser:
class Parser :

    TOKEN_SPECS = (
        ('NL',  r'\n'),
        ('SPC', r'[ \t]+'),
        ('IDENT', r'[a-zA-Z_][a-zA-Z0-9_]*'),
        ('INT', r'[0-9]+'),
        ('ARROW', r'->'),
        ('EQUALEQUAL', r'=='),
        ('SEMICOLON', r';'),
        ('OPEN_BRACE', r'\{'),
        ('CLOSE_BRACE', r'\}'),
        ('OPEN_PAR', r'\('),
        ('CLOSE_PAR', r'\)'),
    )

    RE_LEX = re.compile('|'.join('(?P<%s>%s)' % (n, r) for n, r in TOKEN_SPECS))

    RE_LOCATION = re.compile(r'#\s+(?P<LNO>\d+)\s+"(?P<FNAME>[^"]*)".*$')

    # __init__:
    def __init__ (self, modname) :
        self.modname = modname
        
    # parse:
    def parse (self, fin) :
        self.init(fin)
        ast = self.parse_input()
        return ast

    # init:
    def init (self, fin) :
        self.fin = fin
        self.tokbuf = []
        self.pos = 0
        self.buffer = ''
        self.lineno = 1
        self.fname = '<input>'

    # error:
    def error (self, msg) :
        sys.stderr.write("piftest:%s:%d: %s\n" %
                         (self.fname, self.lineno, msg))
        
    # parse_input:
    def parse_input (self) :
        body = []
        data = None
        while True :
            tok = self.look()
            if tok.tp == 'END' :
                break
            elif tok.tp == 'IDENT' :
                if tok.val == 'data' :
                    if data is not None :
                        self.error("duplicated data block")
                        assert 0
                    data = self.parse_data()
                elif tok.val == 'test' :
                    body.append(self.parse_test())
                else :
                    self.error("unexpected token: '%s' (%s)" %
                               (tok.val, tok.tp))
                    assert 0
            else :
                assert 0, tok
        return ('unit', (), self.modname, data, None, None, tuple(body))

    # parse_data:
    def parse_data (self) :
        self.lex('IDENT', 'data')
        self.lex('OPEN_BRACE')
        code = []
        depth = 1
        while True :
            tok = self.lex(raw=True)
            if tok.tp == 'OPEN_BRACE' :
                depth += 1
            elif tok.tp == 'CLOSE_BRACE' :
                depth -= 1
                if depth == 0 :
                    break
            code.append(tok.val)
        return ('data', (), ''.join(code))        

    # parse_test:
    def parse_test (self) :
        self.lex('IDENT', 'test')
        name = '' # [fixme]
        self.lex('OPEN_BRACE')
        code = []
        depth = 1
        while True :
            tok = self.lex(raw=True)
            if tok.tp == 'OPEN_BRACE' :
                depth += 1
            elif tok.tp == 'CLOSE_BRACE' :
                depth -= 1
                if depth == 0 :
                    break
            code.append(tok.val)
        return ('test', (), name, ''.join(code))

    # lex:
    def lex (self, tp=None, val=None, raw=False) :
        while True :
            if self.tokbuf :
                tok = self.tokbuf.pop()
            else :
                tok = self.__lex()
            if raw or tok.tp not in ('NL', 'SPC') :
                break
        assert tp is None or tp == tok.tp, (tp, tok)
        assert val is None or val == tok.val, (val, tok)
        return tok

    # unlex:
    def unlex (self, tok) :
        self.tokbuf.append(tok)

    # look:
    def look (self, raw=False) :
        tok = self.lex(raw=raw)
        self.unlex(tok)
        return tok

    # __lex:
    def __lex (self) :
        # feed the buffer
        while self.pos >= len(self.buffer) :
            self.pos = 0
            self.buffer = self.fin.readline()
            self.lineno += 1
            if self.buffer == '' :
                return Token('END')
            m = Parser.RE_LOCATION.match(self.buffer)
            if m is not None :
                self.lineno = int(m.group('LNO')) - 1
                self.fname = m.group('FNAME')
                self.buffer = ''
        # get one token
        m = Parser.RE_LEX.match(self.buffer, self.pos)
        assert m is not None, self.buffer[self.pos:]
        assert m.start() == self.pos
        tp = m.lastgroup
        val = self.buffer[m.start():m.end()]
        self.pos = m.end()
        return Token(tp, val)

# ASTContext:
class ASTContext :

    parent = property(lambda s: s.__parent)
    
    def __init__ (self, parent) :
        self.__parent = parent
        self.__attrs = {}
        
    def __setattr__ (s, n, v) :
        if n[0] == '_' :
            object.__setattr__(s, n, v)
        else :
            s.__attrs[n] = v

    def __getattr__ (s, n) :
        if n[0] == '_' :
            return object.__getattr__(s, n)
        else :
            try: return s.__attrs[n]
            except KeyError: return getattr(s.__parent, n)

# ASTVisitor:
class ASTVisitor :

    # process:
    def process (self, node) :
        assert node[0] == 'unit'
        self.modname = node[2]
        self.context = ASTContext(None)
        self.context.unit_path = ''
        self.context.data_stack = ()
        self.writer = Writer()
        self.writer.section('top')
        self.writer.section('includes')
        self.writer.section('typedefs')
        self.writer.section('datadefs')
        self.writer.section('fndecls')
        self.writer.section('modinit')
        self.writer.section('modinit.head')
        self.writer.section('modinit.body')
        self.writer.section('modinit.foot')
        self.writer.section('fndefs')
        self.writer.write('top', '/* AUTO-GENERATED FILE - DO NOT HAND EDIT! */\n')
        self.writer.write('includes',
                          '#include <piftest.h>\n',
                          '#include <piftools.h>\n')
        # init_func
        init_func = get_module_init_func(self.modname)
        self.writer.write('modinit.head',
                          'void %s ( PifSuite *suite )\n' % init_func,
                          '{\n')
        self.writer.write('modinit.foot',
                          '}\n')
        # go
        self.visit(node)

    # visit:
    def visit (self, node) :
        self.context = ASTContext(self.context)
        hdlr = getattr(self, 'visit_' + node[0])
        hdlr(node)
        self.context = self.context.parent

    # visit_unit:
    def visit_unit (self, node) :
        assert len(node) == 7, node
        tp, loc, name, data, setup, teardown, body = node
        # get unit path
        path = self.context.unit_path
        if path == '' : path = name
        else : path = path + '.' + name
        self.context.unit_path = path
        # register the data block
        if data is not None :
            self.context.data_stack = self.context.data_stack + (data,)
        # create the data struct
        data_name = get_data_name(path)
        self.writer.write('typedefs',
                          'typedef struct _%s %s;\n' % (data_name, data_name))
        self.writer.write('datadefs',
                          'struct _%s\n' % data_name,
                          '{\n')
        for block in self.context.data_stack :
            self.writer.write('datadefs', block[2])
        self.writer.write('datadefs', '};\n')
        # unit registration
        self.writer.write('modinit.body',
                          'pif_suite_register_unit(suite, "%s");\n' % path)
        # process children
        for child in body :
            self.visit(child)

    # visit_test:
    def visit_test (self, node) :
        assert len(node) == 4
        tp, loc, name, code = node
        # get unit path
        path = self.context.unit_path
        if path == '' : path = name
        else : path = path + '.' + name
        self.context.unit_path = path
        test_func = get_test_func(path)
        self.writer.write('modinit.body',
                          'pif_suite_register_test(suite, "%s", %s);\n' %
                          (path, test_func))
        self.writer.write('fndecls',
                          'static void %s ( void );\n' % test_func)
        self.writer.write('fndefs',
                          'static void %s ( void )\n' % test_func,
                          '{\n')
        self.writer.write('fndefs', code)
        self.writer.write('fndefs',
                          '}\n')
        

# get_module_init_func:
def get_module_init_func (modname) :
    return '__%s__module_init' % modname

# get_test_func:
def get_test_func (path) :
    return '__%s__test_func' % path.replace('.', '_')

# get_data_name:
def get_data_name (path) :
    return '__%s__data' % path.replace('.', '_')

# newerthan:
#
# True if file2 does not exist or is older than file1. file1 can be a
# single filename or a list, in which case the function returns True
# if file2 is older than at least one of the files in it.
#
def newerthan (file1, file2) :
    if isinstance(file1, str) :
        file1 = (file1,)
    if not os.path.exists(file2) :
        return True
    stamp2 = os.path.getmtime(file2)
    for f in file1 :
        if os.path.getmtime(f) > stamp2 :
            return True
    return False
    
# main:
def main () :
    # create the config
    cfg = Config()
    # parse the command line
    shortopts = 'GMs:b:'
    cmd = ''
    modules = None
    opts, args = getopt.gnu_getopt(sys.argv[1:], shortopts)
    for o, a in opts :
        if o in ('-G',) :
            assert not cmd
            cmd = 'gen-sources'
            assert len(args) == 1, args
            cfgfile, = args
        elif o in ('-M',) :
            assert not cmd
            cmd = 'gen-makefile'
            assert len(args) == 1, args
            subdir, = args
            cfgfile = os.path.join(subdir, 'piftest.conf')
        elif o in ('-b',) :
            cfg.builddir = os.path.realpath(a)
        elif o in ('-s',) :
            cfg.srcdir = a
        else :
            assert 0, (o, a)
    # read the config file
    cfg.read_file(cfgfile)
    # process
    if cmd == 'gen-sources' :
        proc_gen_sources(cfg)
    elif cmd == 'gen-makefile' :
        proc_gen_makefile(cfg, subdir)
    else :
        assert 0, cmd
    
# proc_gen_makefile:
def proc_gen_makefile (cfg, subdir) :
    makefile = os.path.realpath(os.path.join(subdir, 'Makefile.in'))
    trace("generating makefile '%s'" % makefile)
    # [fixme] create the Po files
    if cfg.builddir :
        depsdir = os.path.join(cfg.builddir, '.deps')
        try: os.mkdir(depsdir)
        except OSError as exc:
            if exc.errno != errno.EEXIST : raise
        for base in [cfg.suite] + cfg.modules :
            pofile = os.path.join(depsdir, base+'.Po')
            if not os.path.exists(pofile) :
                with open(pofile, 'wt') as f :
                    f.write('%s.o: %s.c\n' % (base, base))
    # create the writer
    w = Writer()
    s = w.get_section('')
    s.write('# %s\n' % makefile)
    # define some vars
    def subst (n) :
        return '%s = @%s@\n' % (n, n)
    s.write(subst('abs_top_builddir'),
            subst('top_builddir'),
            subst('top_srcdir'),
            subst('srcdir'),
            'subdir = %s\n' % subdir,
            'LIBTOOL = libtool\n', # [fixme] subst('LIBTOOL'),
            subst('CC'),
            'CCLD = $(CC)\n',
            'depcomp = $(top_srcdir)/depcomp\n', # [fixme] subst
            subst('CCDEPMODE'))
    # [fixme]
    s.write_rule('all', None, 'echo "** ALL **" >&2')
    s.write_rule('check', cfg.suite, './%s' % cfg.suite)
    s.write_rule('install', None, 'echo "** INSTALL **" >&2')
    # makefile regeneration
    s.write_rule('Makefile', ('$(srcdir)/Makefile.in', '$(top_builddir)/config.status'),
                 'cd $(top_builddir) && ./config.status --file=$(subdir)/Makefile')
    s.write_rule('$(srcdir)/Makefile.in', [cfg.cfgfile, cfg.progpath],
                 'cd $(top_srcdir) && %s -b %s -M $(subdir)' % (cfg.progpath, cfg.builddir))
    # test suite program
    s.write_rule(cfg.suite, [cfg.suite+'.o'] + [m+'.o' for m in cfg.modules],
                 '$(LIBTOOL) --tag=CC --mode=link $(CCLD) -o $@ $^ $(LDFLAGS) %s' % cfg.ldflags)
    # object compilation
    s.write_rule('.c.o', None,
                 ('test -d .deps || mkdir .deps', # [fixme]
                  'source=$< object=$@ $(CCDEPMODE) DEPDIR=.deps lbtool=yes $(depcomp) $(LIBTOOL) --tag=CC --mode=compile $(CC) -c -o $@ $< $(CFLAGS) %s' % cfg.cflags))
    # include deps
    s.write('include .deps/%s.Po\n' % cfg.suite)
    for m in cfg.modules :
        s.write('include .deps/%s.Po\n' % m)
    # sources generation
    s.write_rule([cfg.suite+'.c'] + [m+'.c' for m in cfg.modules],
                 cfg.suite+'.stamp-h')
    s.write_rule(cfg.suite+'.stamp-h', ['$(srcdir)/'+m+'.in' for m in cfg.modules] + [cfg.cfgfile, cfg.progpath],
                 ('%s -s $(srcdir) -G %s' % (cfg.progpath, cfg.cfgfile),
                  'echo >$@'))
    # output
    # trace("** OUTPUT **")
    # w.dump(sys.stderr)
    # trace("************")
    tmpfile = makefile + '.tmp'
    with open(tmpfile, 'wt') as f :
        w.dump(f)
    os.rename(tmpfile, makefile)
    
# proc_gen_sources:
def proc_gen_sources (cfg) :
    trace("generating sources")
    # generate the main C file (<suite>.c)
    main_c = cfg.suite + '.c'
    if newerthan((cfg.cfgfile, cfg.progpath), main_c) :
        trace("  + %s" % main_c)
        _proc_gen_main(cfg, main_c)
    else :
        trace("  - %s" % main_c)
    # generate the modules
    for mod in cfg.modules :
        mod_in = os.path.join(cfg.srcdir, mod+'.in')
        mod_c = mod+'.c'
        if newerthan((cfg.cfgfile, cfg.progpath, mod_in), mod_c) :
            trace("  + %s (%s)" % (mod_c, mod_in))
            _proc_gen_source(cfg, mod, mod_in, mod_c)
        else :
            trace("  - %s (%s)" % (mod_c, mod_in))

# _proc_gen_main:
def _proc_gen_main (cfg, main_c) :
    w = Writer()
    w.section('includes')
    w.section('fndecls')
    w.section('main')
    w.section('main.head')
    w.section('main.decls')
    w.section('main.init')
    w.section('main.modinit')
    w.section('main.body')
    w.section('main.foot')
    # includes
    w.write('includes',
            '#include <piftest.h>\n')
    # main
    w.write('main.head',
            'int main ()\n',
            '{\n')
    w.write('main.foot',
            '}\n')
    # suite init
    w.write('main.decls',
            'PifSuite *suite;\n')
    w.write('main.init',
            'suite = pif_suite_new("%s");\n' % cfg.suite)
    # run
    w.write('main.body',
            'pif_suite_run(suite, ".");\n',
            'return 0;') # [todo]
    # modules
    for mod in cfg.modules :
        init_func = get_module_init_func(mod)
        w.write('fndecls',
                'void %s ( PifSuite *suite );\n' % init_func)
        w.write('main.modinit',
                '%s(suite);\n' % init_func)
    # output
    tmpfile = main_c + '.tmp'
    with open(tmpfile, 'wt') as f :
        w.dump(f)
    os.rename(tmpfile, main_c)

# _proc_gen_source:
def _proc_gen_source (cfg, mod_name, mod_in, mod_c) :
    # start cpp
    cpp_cmd = ['cpp', mod_in]
    cpp_proc = subprocess.Popen(cpp_cmd,
                                stdout=subprocess.PIPE,
                                universal_newlines=True)
    # parse output
    parser = Parser(mod_name)
    ast = parser.parse(cpp_proc.stdout)
    # terminate cpp
    r = cpp_proc.wait()
    assert r == 0, r
    # ...
    trace("AST:\n%s" % pprint.pformat(ast))
    # process the tree
    visitor = ASTVisitor()
    visitor.process(ast)
    # output
    tmpfile = mod_c + '.tmp'
    with open(tmpfile, 'wt') as f :
        visitor.writer.dump(f)
    os.rename(tmpfile, mod_c)

# exec
if __name__ == '__main__' :
    main()
