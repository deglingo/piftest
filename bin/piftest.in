#!@PYTHON@
# -*- python -*-

import sys, os, getopt, configparser, subprocess, re, pprint

# trace:
def trace (msg) :
    sys.stderr.write('piftest: %s\n' % msg)

# Config:
class Config :

    # __init__:
    def __init__ (self) :
        self.progpath = os.path.realpath(sys.argv[0])
        self.cfgfile = 'piftest.conf'

    # read_file:
    def read_file (self) :
        parser = configparser.ConfigParser()
        parser.read_file(open(self.cfgfile, 'rt'))
        self.suite = parser['DEFAULT']['suite']
        self.makefile = self.suite + '.mk'
        self.modules = parser['DEFAULT']['modules'].split()

# Writer:
class Writer :

    # __init__:
    def __init__ (self) :
        self.root = WSection()

    # get_section:
    def get_section (self, path) :
        s = self.root
        if path != '' :
            for comp in path.split('.') :
                s = s.children[comp]
        return s

    # section:
    def section (self, path) :
        dot = path.rfind('.')
        if dot < 0 :
            parent = self.root
            name = path
        else :
            parent = self.get_section(path[:dot])
            name = path[dot+1:]
        parent.add_child(name)

    # write:
    def write (self, section, *text) :
        s = self.get_section(section)
        s.write(*text)
        
    # write_rule:
    def write_rule (self, section, targets, prereqs=None, recipe=None) :
        s = self.get_section(section)
        s.write_rule(targets, prereqs, recipe)

    # dump:
    def dump (self, f) :
        self.root.dump(f)

# WSection:
class WSection :

    # __init__:
    def __init__ (self) :
        self.nodes = []
        self.children = {}

    # add_child:
    def add_child (self, name) :
        assert name not in self.children, name
        child = WSection()
        self.nodes.append(child)
        self.children[name] = child
        
    # dump:
    def dump (self, f) :
        for n in self.nodes :
            n.dump(f)

    # write:
    def write (self, *text) :
        self.nodes.extend(WText(t) for t in text)

    # write_rule:
    def write_rule (self, targets, prereqs=None, recipe=None) :
        self.nodes.append(WRule(targets, prereqs, recipe))

# WText:
class WText :

    # __init__:
    def __init__ (self, text) :
        self.text = text

    # dump:
    def dump (self, f) :
        f.write(self.text)

# WRule:
class WRule :

    # __init__
    def __init__ (self, targets, prereqs=None, recipe=None) :
        self.targets = self._fixlist(targets)
        self.prereqs = self._fixlist(prereqs)
        self.recipe = self._fixlist(recipe)

    def _fixlist (self, arg) :
        if arg is None : return ()
        elif isinstance(arg, str) : return (arg,)
        else : return tuple(arg)

    # dump:
    def dump (self, f) :
        f.write(' '.join(self.targets))
        f.write(': ')
        f.write(' '.join(self.prereqs))
        f.write('\n')
        for c in self.recipe :
            f.write('\t%s\n' % c)

# Token:
class Token :

    def __init__ (self, tp, val='') :
        self.tp = tp
        self.val = val

    def __repr__ (self) :
        return '<%s "%s">' % (self.tp, self.val.replace('\n', '\\n'))

# Parser:
class Parser :

    RE_LOCATION = re.compile(r'#\s+(?P<LNO>\d+)\s+"(?P<FNAME>[^"]*)".*$')

    # __init__:
    def __init__ (self, modname) :
        self.modname = modname
        
    # parse:
    def parse (self, fin) :
        self.init(fin)
        ast = self.parse_input()
        return ast

    # init:
    def init (self, fin) :
        self.fin = fin
        self.tokbuf = []
        self.pos = 0
        self.buffer = ''
        
    # parse_input:
    def parse_input (self) :
        tok = self.look()
        if tok.tp == 'END' :
            return ('unit', (), self.modname, None, None, None, ())
        else :
            assert 0, tok

    # lex:
    def lex (self) :
        if self.tokbuf :
            tok = self.tokbuf.pop()
        else :
            tok = self.__lex()
        return tok

    # unlex:
    def unlex (self, tok) :
        self.tokbuf.append(tok)

    # look:
    def look (self) :
        tok = self.lex()
        self.unlex(tok)
        return tok

    # __lex:
    def __lex (self) :
        # feed the buffer
        while self.pos >= len(self.buffer) :
            self.pos = 0
            self.buffer = self.fin.readline()
            if self.buffer == '' :
                return Token('END')
            m = Parser.RE_LOCATION.match(self.buffer)
            if m is not None :
                lno = int(m.group('LNO'))
                fname = m.group('FNAME')
                # trace("[TODO] location: %d, '%s'" % (lno, fname))
                self.buffer = ''
        assert 0, self.buffer

# ASTContext:
class ASTContext :

    parent = property(lambda s: s.__parent)
    
    def __init__ (self, parent) :
        self.__parent = parent
        self.__attrs = {}
        
    def __setattr__ (s, n, v) :
        if n[0] == '_' :
            object.__setattr__(s, n, v)
        else :
            s.__attrs[n] = v

    def __getattr__ (s, n) :
        if n[0] == '_' :
            return object.__getattr__(s, n)
        else :
            try: return s.__attrs[n]
            except KeyError: return getattr(s.__parent, n)

# ASTVisitor:
class ASTVisitor :

    # process:
    def process (self, node) :
        assert node[0] == 'unit'
        self.modname = node[2]
        self.context = ASTContext(None)
        self.context.unit_path = ''
        self.writer = Writer()
        self.writer.section('top')
        self.writer.section('modinit')
        self.writer.section('modinit.head')
        self.writer.section('modinit.body')
        self.writer.section('modinit.foot')
        self.writer.write('top', '/* AUTO-GENERATED FILE - DO NOT HAND EDIT! */\n')
        # init_func
        init_func = get_module_init_func(self.modname)
        self.writer.write('modinit.head',
                          'void %s ( void )\n' % init_func,
                          '{\n')
        self.writer.write('modinit.foot',
                          '}\n')
        # go
        self.visit(node)

    # visit:
    def visit (self, node) :
        self.context = ASTContext(self.context)
        hdlr = getattr(self, 'visit_' + node[0])
        hdlr(node)
        self.context = self.context.parent

    # visit_unit:
    def visit_unit (self, node) :
        assert len(node) == 7, node
        tp, loc, name, data, setup, teardown, body = node
        # get unit path
        path = self.context.unit_path
        if path == '' : path = name
        else : path = path + '.' + name
        self.context.unit_path = path
        self.writer.write('modinit.body',
                          '/* pif_unit_register("%s"); */\n' % path)
        for child in body :
            self.visit(child)

# get_module_init_func:
def get_module_init_func (modname) :
    return '__%s__module_init' % modname

# main:
def main () :
    # create the config
    cfg = Config()
    # parse the command line
    shortopts = 'MCB'
    cmd = ''
    src = ''
    dest = ''
    opts, args = getopt.gnu_getopt(sys.argv[1:], shortopts)
    for o, a in opts :
        if o in ('-M',) :
            assert not cmd
            cmd = 'gen-makefile'
        elif o in ('-C',) :
            assert not cmd
            cmd = 'gen-source'
            assert len(args) == 2, args
            src, dest = args
        elif o in ('-B',) :
            assert not cmd
            cmd = 'gen-main'
            assert len(args) == 1, args
            dest, = args
        else :
            assert 0, (o, a)
    # read the config file
    cfg.read_file()
    # process
    if cmd == 'gen-makefile' :
        proc_gen_makefile(cfg)
    elif cmd == 'gen-source' :
        proc_gen_source(cfg, src, dest)
    elif cmd == 'gen-main' :
        proc_gen_main(cfg, dest)
    else :
        assert 0, cmd

# proc_gen_makefile:
def proc_gen_makefile (cfg) :
    trace("generating makefile: '%s'" % cfg.makefile)
    w = Writer()
    s = w.get_section('')
    mod_objs = [m+'.o' for m in cfg.modules]
    # makefile dependencies
    s.write_rule(cfg.makefile, [cfg.progpath, cfg.cfgfile])
    # main prog
    # [fixme] add $(LDFLAGS) ?
    s.write_rule(cfg.suite, [cfg.suite+'.o'] + mod_objs,
                 'libtool --tag=CC --mode=link $(CC) -o $@ $^')
    # objects compilation recipe
    s.write_rule('%.o', None,
                 'libtool --tag=CC --mode=compile $(CC) -c -o $@ $< $(CFLAGS)')
    # main object
    s.write_rule(cfg.suite+'.o', cfg.suite+'.c')
    s.write_rule(cfg.suite+'.c', [cfg.progpath, cfg.cfgfile],
                 '%s -B $@' % cfg.progpath)
    # [fixme] objects depends
    for mod in cfg.modules :
        s.write_rule(mod+'.o', mod+'.c')
    # sources generation rules
    s.write_rule([m+'.c' for m in cfg.modules], None,
                 '%s -C $< $@' % cfg.progpath)
    for mod in cfg.modules :
        s.write_rule(mod+'.c', [mod+'.in', cfg.progpath, cfg.cfgfile])
    # output
    # trace("**  OUTPUT  **")
    # w.dump(sys.stderr)
    # trace("**************")
    tmpfile = cfg.makefile + '.tmp'
    with open(tmpfile, 'wt') as f :
        w.dump(f)
    os.rename(tmpfile, cfg.makefile)

# proc_gen_source:
def proc_gen_source (cfg, src, dest) :
    modname = os.path.splitext(os.path.basename(dest))[0]
    trace("generating module '%s' ('%s' -> '%s')" %
          (modname, src, dest))
    cpp_cmd = ['cpp', src]
    cpp_proc = subprocess.Popen(cpp_cmd,
                                stdout=subprocess.PIPE,
                                universal_newlines=True)
    parser = Parser(modname)
    ast = parser.parse(cpp_proc.stdout)
    r = cpp_proc.wait()
    assert r == 0, r
    trace("AST:\n%s" % pprint.pformat(ast))
    visitor = ASTVisitor()
    visitor.process(ast)
    # output
    tmpfile = dest + '.tmp'
    with open(tmpfile, 'wt') as f :
        visitor.writer.dump(f)
    os.rename(tmpfile, dest)

# proc_gen_main:
def proc_gen_main (cfg, dest) :
    trace("generating main source: '%s'" % dest)
    w = Writer()
    w.section('includes')
    w.section('fndecls')
    w.section('main')
    w.section('main.head')
    w.section('main.init')
    w.section('main.body')
    w.section('main.foot')
    w.write('main.head',
            'int main ()\n',
            '{\n')
    w.write('main.foot',
            '}\n')
    for mod in cfg.modules :
        init_func = get_module_init_func(mod)
        w.write('fndecls', 'void %s ( void );\n' % init_func)
        w.write('main.init', '%s();\n' % init_func)
    w.write('main.body', 'return 0;\n')
    # output
    tmpfile = dest + '.tmp'
    with open(tmpfile, 'wt') as f :
        w.dump(f)
    os.rename(tmpfile, dest)
    
# exec
if __name__ == '__main__' :
    main()
